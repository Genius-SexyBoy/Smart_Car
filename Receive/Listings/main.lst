C51 COMPILER V9.54   MAIN                                                                  05/05/2017 20:22:54 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          
   2          
   3          
   4          #include <reg51.h>
   5          #include <api.h>
   6          
   7          #define uchar unsigned char
   8          #define uint  unsigned int
   9          
  10          /***************************************************/
  11          #define TX_ADR_WIDTH   5  // 5×Ö½Ú¿í¶ÈµÄ·¢ËÍ/½ÓÊÕµØÖ·
  12          #define TX_PLOAD_WIDTH 6  // Êý¾ÝÍ¨µÀÓÐÐ§Êý¾Ý¿í¶È
  13          
  14          sbit CE   = P2^5;
  15          sbit CSN  = P2^4;
  16          sbit SCK  = P2^3;
  17          sbit MOSI = P2^2;
  18          sbit MISO = P2^1;
  19          sbit IRQ  = P2^0;
  20          //sbit KEY  = P3^4;
  21          
  22          //Aµç»ú¿ØÖÆ¶Ë¿Ú ×ó±ß
  23          //sbit ENA = P1^0;
  24          sbit IN1 = P1^1;
  25          sbit IN2 = P1^2;
  26          
  27          //Bµç»ú¿ØÖÆ¶Ë¿Ú ÓÒ±ß
  28          sbit IN3 = P1^3;
  29          sbit IN4 = P1^4;
  30          //sbit ENB = P1^5;
  31          
  32          uchar code TX_ADDRESS[TX_ADR_WIDTH] = {0x34,0x43,0x10,0x10,0x01};  // ¶¨ÒåÒ»¸ö¾²Ì¬·¢ËÍµØÖ·
  33          volatile uchar RX_BUF[TX_PLOAD_WIDTH];
  34          uchar TX_BUF[TX_PLOAD_WIDTH];
  35          uchar flag;
  36          //uchar DATA = 0x01;
  37          uchar bdata sta;
  38          sbit  RX_DR  = sta^6;
  39          sbit  TX_DS  = sta^5;
  40          sbit  MAX_RT = sta^4;
  41          /**************************************************/
  42          
  43          /**************************************************
  44          º¯Êý: init_io()
  45          
  46          ÃèÊö:
  47              ³õÊ¼»¯IO
  48          /**************************************************/
  49          void init_io(void)
  50          {
  51   1        CE  = 0;        // ´ý»ú
  52   1        CSN = 1;        // SPI½ûÖ¹
  53   1        SCK = 0;        // SPIÊ±ÖÓÖÃµÍ
  54   1        IRQ = 1;        // ÖÐ¶Ï¸´Î»
C51 COMPILER V9.54   MAIN                                                                  05/05/2017 20:22:54 PAGE 2   

  55   1      }
  56          /**************************************************/
  57          
  58          
  59          
  60          
  61          
  62          
  63          /**************************************************
  64          º¯Êý£ºSPI_RW()
  65          
  66          ÃèÊö£º
  67              ¸ù¾ÝSPIÐ­Òé£¬Ð´Ò»×Ö½ÚÊý¾Ýµ½nRF24L01£¬Í¬Ê±´ÓnRF24L01
  68            ¶Á³öÒ»×Ö½Ú
  69          /**************************************************/
  70          uchar SPI_RW(uchar byte)
  71          {
  72   1        uchar i;
  73   1          for(i=0; i<8; i++)          // Ñ­»·8´Î
  74   1          {
  75   2            MOSI = (byte & 0x80);   // byte×î¸ßÎ»Êä³öµ½MOSI
  76   2            byte <<= 1;             // µÍÒ»Î»ÒÆÎ»µ½×î¸ßÎ»
  77   2            SCK = 1;                // À­¸ßSCK£¬nRF24L01´ÓMOSI¶ÁÈë1Î»Êý¾Ý£¬Í¬Ê±´ÓMISOÊä³ö1Î»Êý¾Ý
  78   2            byte |= MISO;         // ¶ÁMISOµ½byte×îµÍÎ»
  79   2            SCK = 0;              // SCKÖÃµÍ
  80   2          }
  81   1          return(byte);             // ·µ»Ø¶Á³öµÄÒ»×Ö½Ú
  82   1      }
  83          /**************************************************/
  84          
  85          /**************************************************
  86          º¯Êý£ºSPI_RW_Reg()
  87          
  88          ÃèÊö£º
  89              Ð´Êý¾Ývalueµ½reg¼Ä´æÆ÷
  90          /**************************************************/
  91          uchar SPI_RW_Reg(uchar reg, uchar value)
  92          {
  93   1        uchar status;
  94   1          CSN = 0;                   // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
  95   1          status = SPI_RW(reg);      // Ñ¡Ôñ¼Ä´æÆ÷£¬Í¬Ê±·µ»Ø×´Ì¬×Ö
  96   1          SPI_RW(value);             // È»ºóÐ´Êý¾Ýµ½¸Ã¼Ä´æÆ÷
  97   1          CSN = 1;                   // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
  98   1          return(status);            // ·µ»Ø×´Ì¬¼Ä´æÆ÷
  99   1      }
 100          /**************************************************/
 101          
 102          /**************************************************
 103          º¯Êý£ºSPI_Read()
 104          
 105          ÃèÊö£º
 106              ´Óreg¼Ä´æÆ÷¶ÁÒ»×Ö½Ú
 107          /**************************************************/
 108          uchar SPI_Read(uchar reg)
 109          {
 110   1        uchar reg_val;
 111   1          CSN = 0;                    // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 112   1          SPI_RW(reg);                // Ñ¡Ôñ¼Ä´æÆ÷
 113   1          reg_val = SPI_RW(0);        // È»ºó´Ó¸Ã¼Ä´æÆ÷¶ÁÊý¾Ý
 114   1          CSN = 1;                    // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 115   1          return(reg_val);            // ·µ»Ø¼Ä´æÆ÷Êý¾Ý
 116   1      }
C51 COMPILER V9.54   MAIN                                                                  05/05/2017 20:22:54 PAGE 3   

 117          
 118          
 119          /**************************************************
 120          º¯Êý£ºSPI_Read_Buf()
 121          
 122          ÃèÊö£º
 123              ´Óreg¼Ä´æÆ÷¶Á³öbytes¸ö×Ö½Ú£¬Í¨³£ÓÃÀ´¶ÁÈ¡½ÓÊÕÍ¨µÀ
 124            Êý¾Ý»ò½ÓÊÕ/·¢ËÍµØÖ·
 125          /**************************************************/
 126          uchar SPI_Read_Buf(uchar reg, uchar * pBuf, uchar bytes)
 127          {
 128   1        uchar status, i;
 129   1          CSN = 0;                    // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 130   1          status = SPI_RW(reg);       // Ñ¡Ôñ¼Ä´æÆ÷£¬Í¬Ê±·µ»Ø×´Ì¬×Ö
 131   1          for(i=0; i<bytes; i++)
 132   1            pBuf[i] = SPI_RW(0);    // Öð¸ö×Ö½Ú´ÓnRF24L01¶Á³ö
 133   1          CSN = 1;                    // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 134   1          return(status);             // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 135   1      }
 136          
 137          /**************************************************
 138          º¯Êý£ºSPI_Write_Buf()
 139          
 140          ÃèÊö£º
 141              °ÑpBuf»º´æÖÐµÄÊý¾ÝÐ´Èëµ½nRF24L01£¬Í¨³£ÓÃÀ´Ð´Èë·¢
 142            ÉäÍ¨µÀÊý¾Ý»ò½ÓÊÕ/·¢ËÍµØÖ·
 143          /**************************************************/
 144          uchar SPI_Write_Buf(uchar reg, uchar * pBuf, uchar bytes)
 145          {
 146   1        uchar status, i;
 147   1          CSN = 0;                    // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 148   1          status = SPI_RW(reg);       // Ñ¡Ôñ¼Ä´æÆ÷£¬Í¬Ê±·µ»Ø×´Ì¬×Ö
 149   1          for(i=0; i<bytes; i++)
 150   1            SPI_RW(pBuf[i]);        // Öð¸ö×Ö½ÚÐ´ÈënRF24L01
 151   1          CSN = 1;                    // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 152   1          return(status);             // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 153   1      }
 154          
 155          /**************************************************
 156          º¯Êý£ºRX_Mode()
 157          
 158          ÃèÊö£º
 159              Õâ¸öº¯ÊýÉèÖÃnRF24L01Îª½ÓÊÕÄ£Ê½£¬µÈ´ý½ÓÊÕ·¢ËÍÉè±¸µÄÊý¾Ý°ü
 160          /**************************************************/
 161          void RX_Mode(void)
 162          {
 163   1        CE = 0;
 164   1          SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH);  // ½ÓÊÕÉè±¸½ÓÊÕÍ¨µÀ0Ê¹ÓÃºÍ·¢ËÍÉè±¸ÏàÍ
             -¬µÄ·¢ËÍµØÖ·
 165   1          SPI_RW_Reg(WRITE_REG + EN_AA, 0x00);               // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0×Ô¶¯Ó¦´ð
 166   1          SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);           // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0
 167   1          SPI_RW_Reg(WRITE_REG + RF_CH, 30);                 // Ñ¡ÔñÉäÆµÍ¨µÀ0x40
 168   1          SPI_RW_Reg(WRITE_REG + RX_PW_P0, TX_PLOAD_WIDTH);  // ½ÓÊÕÍ¨µÀ0Ñ¡ÔñºÍ·¢ËÍÍ¨µÀÏàÍ¬ÓÐÐ§Êý¾Ý¿í¶È
 169   1          SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x07);            // Êý¾Ý´«ÊäÂÊ1Mbps£¬·¢Éä¹¦ÂÊ0dBm£¬µÍÔëÉù·Å´óÆ÷ÔöÒæ
 170   1          SPI_RW_Reg(WRITE_REG + CONFIG, 0x0f);              // CRCÊ¹ÄÜ£¬16Î»CRCÐ£Ñé£¬ÉÏµç£¬½ÓÊÕÄ£Ê½
 171   1        CE = 1;                                            // À­¸ßCEÆô¶¯½ÓÊÕÉè±¸
 172   1      }
 173          /**************************************************/
 174          
 175          /**************************************************
 176          º¯Êý£ºTX_Mode()
 177          
C51 COMPILER V9.54   MAIN                                                                  05/05/2017 20:22:54 PAGE 4   

 178          ÃèÊö£º
 179              Õâ¸öº¯ÊýÉèÖÃnRF24L01Îª·¢ËÍÄ£Ê½£¬£¨CE=1³ÖÐøÖÁÉÙ10us£©£¬
 180            130usºóÆô¶¯·¢Éä£¬Êý¾Ý·¢ËÍ½áÊøºó£¬·¢ËÍÄ£¿é×Ô¶¯×ªÈë½ÓÊÕ
 181            Ä£Ê½µÈ´ýÓ¦´ðÐÅºÅ¡£
 182          /**************************************************/
 183          //void TX_Mode(uchar * BUF)
 184          //{
 185          //  CE = 0;
 186          //    SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);     // Ð´Èë·¢ËÍµØÖ·
 187          //    SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH);  // ÎªÁËÓ¦´ð½ÓÊÕÉè±¸£¬½ÓÊÕÍ¨µÀ0µØÖ·º
             -Í·¢ËÍµØÖ·ÏàÍ¬
 188          //    SPI_Write_Buf(WR_TX_PLOAD, BUF, TX_PLOAD_WIDTH);                  // Ð´Êý¾Ý°üµ½TX FIFO
 189          //    SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);       // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0×Ô¶¯Ó¦´ð
 190          //    SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);   // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0
 191          //    SPI_RW_Reg(WRITE_REG + SETUP_RETR, 0x0a);  // ×Ô¶¯ÖØ·¢ÑÓÊ±µÈ´ý250us+86us£¬×Ô¶¯ÖØ·¢10´Î
 192          //    SPI_RW_Reg(WRITE_REG + RF_CH, 40);         // Ñ¡ÔñÉäÆµÍ¨µÀ0x40
 193          //    SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x07);    // Êý¾Ý´«ÊäÂÊ1Mbps£¬·¢Éä¹¦ÂÊ0dBm£¬µÍÔëÉù·Å´óÆ÷ÔöÒæ
 194          //    SPI_RW_Reg(WRITE_REG + CONFIG, 0x0e);      // CRCÊ¹ÄÜ£¬16Î»CRCÐ£Ñé£¬ÉÏµç
 195          //  CE = 1;
 196          //}
 197          /**************************************************/
 198          
 199          /**************************************************
 200          º¯Êý£ºCheck_ACK()
 201          
 202          ÃèÊö£º
 203              ¼ì²é½ÓÊÕÉè±¸ÓÐÎÞ½ÓÊÕµ½Êý¾Ý°ü£¬Éè¶¨Ã»ÓÐÊÕµ½Ó¦´ðÐÅ
 204            ºÅÊÇ·ñÖØ·¢
 205          /**************************************************/
 206          //uchar Check_ACK(bit clear)
 207          //{
 208          //  while(IRQ);
 209          //  sta = SPI_RW(NOP);                    // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 210          //  if(MAX_RT)
 211          //    if(clear)                         // ÊÇ·ñÇå³ýTX FIFO£¬Ã»ÓÐÇå³ýÔÚ¸´Î»MAX_RTÖÐ¶Ï±êÖ¾ºóÖØ·¢
 212          //      SPI_RW(FLUSH_TX);
 213          //  SPI_RW_Reg(WRITE_REG + STATUS, sta);  // Çå³ýTX_DS»òMAX_RTÖÐ¶Ï±êÖ¾
 214          //  IRQ = 1;
 215          //  if(TX_DS)
 216          //    return(0x00);
 217          //  else
 218          //    return(0xff);
 219          //}
 220          /**************************************************/
 221          
 222          
 223          //void Set_motor(uchar num,uchar mode)
 224          //{
 225          //  if(num==1)                                     //×ó±ßµç»ú
 226          //  {
 227          //    if(mode==1)
 228          //      {IN1=0;IN2=1;ENA=1;}//Õý×ª
 229          //    else if(mode==2)
 230          //        {IN1=1;IN2=0;ENA=1;}//·´×ª
 231          //    else
 232          //      {IN1=1;IN2=1;ENA=1;}//É²³µ
 233          //  }
 234          //  else if(num==2)                              //ÓÒ±ßµç»ú
 235          //  {
 236          //    if(mode==1)
 237          //      {IN3=0;IN4=1;ENB=1;}//Õý×ª
 238          //    else if(mode==2)
C51 COMPILER V9.54   MAIN                                                                  05/05/2017 20:22:54 PAGE 5   

 239          //        {IN3=1;IN4=0;ENB=1;}//·´×ª
 240          //    else
 241          //      {IN3=1;IN4=1;ENB=1;}//É²³µ
 242          //  }
 243          //}
 244          
 245          
 246          /**************************************************
 247          º¯Êý£ºmain()
 248          
 249          ÃèÊö£º
 250              Ö÷º¯Êý
 251          /**************************************************/
 252          void main(void)
 253          {
 254   1        init_io();                  // ³õÊ¼»¯IO
 255   1        RX_Mode();                  // ÉèÖÃÎª½ÓÊÕÄ£Ê½
 256   1        P0 = 0xff;
 257   1        while(1)
 258   1        {
 259   2        
 260   2      //    LED = 0;
 261   2          sta = SPI_Read(STATUS);   // ¶Á×´Ì¬¼Ä´æÆ÷
 262   2            if(RX_DR)         // ÅÐ¶ÏÊÇ·ñ½ÓÊÜµ½Êý¾Ý
 263   2          {
 264   3            SPI_Read_Buf(RD_RX_PLOAD, RX_BUF, TX_PLOAD_WIDTH);  // ´ÓRX FIFO¶Á³öÊý¾Ý
 265   3            flag = 1;
 266   3          }
 267   2          SPI_RW_Reg(WRITE_REG + STATUS, sta);  // Çå³ýRX_DSÖÐ¶Ï±êÖ¾
 268   2          //delay_ms();  
 269   2          if(flag)               // ½ÓÊÜÍê³É
 270   2          {     
 271   3            flag = 0;          // Çå±êÖ¾      
 272   3            
 273   3            if(RX_BUF[4] == 0x11 && RX_BUF[5] == 0x11)      //Ç°½ø
 274   3            {
 275   4              IN1 = 0;    IN2 = 1;                            
 276   4              IN3 = 0;    IN4 = 1;
 277   4              
 278   4            }
 279   3            else if(RX_BUF[4] == 0x22 && RX_BUF[5] == 0x22)      //ºóÍË
 280   3            {
 281   4              IN1 = 1;    IN2 = 0;                            
 282   4              IN3 = 1;    IN4 = 0;
 283   4              
 284   4            }
 285   3            else if(RX_BUF[4] == 0x33 && RX_BUF[5] == 0x33)      //×ó×ª
 286   3            {
 287   4              IN1 = 1;    IN2 = 0;                            
 288   4              IN3 = 0;    IN4 = 1;
 289   4              
 290   4            }
 291   3            else if(RX_BUF[4] == 0x44 && RX_BUF[5] == 0x44)      //ÓÒ×ª
 292   3            {
 293   4              IN1 = 0;    IN2 = 1;                            
 294   4              IN3 = 1;    IN4 = 0;
 295   4              
 296   4            }
 297   3            else if(RX_BUF[4] == 0x55 && RX_BUF[5] == 0x55)      //É²³µ
 298   3            {
 299   4              IN1 = 1;    IN2 = 1;                            
 300   4              IN3 = 1;    IN4 = 1;
C51 COMPILER V9.54   MAIN                                                                  05/05/2017 20:22:54 PAGE 6   

 301   4            }
 302   3          }
 303   2        }
 304   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    364    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14      10
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
